{
  "agent_name": "es_agent_v2",
  "system_prompt": "You are a helpful assistant that answers questions about documentation.  \n\nUse the search tool to find relevant information from the repository before answering questions.  \n\nIf you can find specific information through search, use it to provide accurate answers.\n\nAlways include references by citing the filename of the source material you used.\nReplace it with the full path to the GitHub repository:\n\"https://github.com/elastic/elasticsearch/blob/main/\"\nFormat: [LINK TITLE](FULL_GITHUB_LINK)\n\n\nIf the search doesn't return relevant results, let the user know and provide general guidance.",
  "provider": "openai",
  "model": "gpt-4o-mini",
  "tools": [
    "search"
  ],
  "messages": [
    {
      "parts": [
        {
          "content": "What is the importance of flattening nested objects in the `attributes` and `resource.attributes` maps for Elastic Search?",
          "timestamp": "2025-10-03T06:01:06.011226+00:00",
          "part_kind": "user-prompt"
        }
      ],
      "instructions": "You are a helpful assistant that answers questions about documentation.  \n\nUse the search tool to find relevant information from the repository before answering questions.  \n\nIf you can find specific information through search, use it to provide accurate answers.\n\nAlways include references by citing the filename of the source material you used.\nReplace it with the full path to the GitHub repository:\n\"https://github.com/elastic/elasticsearch/blob/main/\"\nFormat: [LINK TITLE](FULL_GITHUB_LINK)\n\n\nIf the search doesn't return relevant results, let the user know and provide general guidance.",
      "kind": "request"
    },
    {
      "parts": [
        {
          "tool_name": "search",
          "args": "{\"query\":\"flattening nested objects in attributes and resource.attributes maps\"}",
          "tool_call_id": "call_DJ6Y321I7B9DhMTZV5vUufsj",
          "part_kind": "tool-call"
        }
      ],
      "usage": {
        "input_tokens": 225,
        "cache_write_tokens": 0,
        "cache_read_tokens": 0,
        "output_tokens": 22,
        "input_audio_tokens": 0,
        "cache_audio_read_tokens": 0,
        "output_audio_tokens": 0,
        "details": {
          "accepted_prediction_tokens": 0,
          "audio_tokens": 0,
          "reasoning_tokens": 0,
          "rejected_prediction_tokens": 0
        }
      },
      "model_name": "gpt-4o-mini-2024-07-18",
      "timestamp": "2025-10-03T06:01:06+00:00",
      "kind": "response",
      "provider_name": "openai",
      "provider_details": {
        "finish_reason": "tool_calls"
      },
      "provider_response_id": "chatcmpl-CMT8kH1ed0o8nPSLS8FWdLnHx5EIw",
      "finish_reason": "tool_call"
    },
    {
      "parts": [
        {
          "tool_name": "search",
          "content": [
            {
              "navigation_title": "Nested",
              "mapped_pages": [
                "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-nested-aggregation.html"
              ],
              "content": "# Nested aggregation [search-aggregations-bucket-nested-aggregation]\n\n\nA special single bucket aggregation that enables aggregating nested documents.\n\nFor example, lets say we have an index of products, and each product holds the list of resellers - each having its own price for the product. The mapping could look like:\n\n$$$nested-aggregation-example$$$\n\n```console\nPUT /products\n{\n  \"mappings\": {\n    \"properties\": {\n      \"resellers\": { <1>\n        \"type\": \"nested\",\n        \"properties\": {\n          \"reseller\": {\n            \"type\": \"keyword\"\n          },\n          \"price\": {\n            \"type\": \"double\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n1. `resellers` is an array that holds nested documents.\n\n\nThe following request adds a product with two resellers:\n\n```console\nPUT /products/_doc/0?refresh\n{\n  \"name\": \"LED TV\", <1>\n  \"resellers\": [\n    {\n      \"reseller\": \"companyA\",\n      \"price\": 350\n    },\n    {\n      \"reseller\": \"companyB\",\n      \"price\": 500\n    }\n  ]\n}\n```\n\n1. We are using a dynamic mapping for the `name` attribute.\n\n\nThe following request returns the minimum price a product can be purchased for:\n\n```console\nGET /products/_search?size=0\n{\n  \"query\": {\n    \"match\": {\n      \"name\": \"led tv\"\n    }\n  },\n  \"aggs\": {\n    \"resellers\": {\n      \"nested\": {\n        \"path\": \"resellers\"\n      },\n      \"aggs\": {\n        \"min_price\": {\n          \"min\": {\n            \"field\": \"resellers.price\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nAs you can see above, the nested aggregation requires the `path` of the nested documents within the top level documents. Then one can define any type of aggregation over these nested documents.\n\nResponse:\n\n```console-result\n{\n  ...\n  \"aggregations\": {\n    \"resellers\": {\n      \"doc_count\": 2,\n      \"min_price\": {\n        \"value\": 350.0\n      }\n    }\n  }\n}\n```\n\nYou can use a [`filter`](/reference/aggregations/search-aggregations-bucket-filter-aggregation.md) sub-aggregation to return results for a specific reseller.\n\n```console\nGET /products/_search?size=0\n{\n  \"query\": {\n    \"match\": {\n      \"name\": \"led tv\"\n    }\n  },\n  \"aggs\": {\n    \"resellers\": {\n      \"nested\": {\n        \"path\": \"resellers\"\n      },\n      \"aggs\": {\n        \"filter_reseller\": {\n          \"filter\": {\n            \"bool\": {\n              \"filter\": [\n                {\n                  \"term\": {\n                    \"resellers.reseller\": \"companyB\"\n                  }\n                }\n              ]\n            }\n          },\n          \"aggs\": {\n            \"min_price\": {\n              \"min\": {\n                \"field\": \"resellers.price\"\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nThe search returns:\n\n```console-result\n{\n  ...\n  \"aggregations\": {\n    \"resellers\": {\n      \"doc_count\": 2,\n      \"filter_reseller\": {\n        \"doc_count\": 1,\n        \"min_price\": {\n          \"value\": 500.0\n        }\n      }\n    }\n  }\n}\n```",
              "filename": "elasticsearch-main/docs/reference/aggregations/search-aggregations-bucket-nested-aggregation.md"
            },
            {
              "navigation_title": "Flattened",
              "mapped_pages": [
                "https://www.elastic.co/guide/en/elasticsearch/reference/current/flattened.html"
              ],
              "content": "# Flattened field type [flattened]\n\n\nBy default, each subfield in an object is mapped and indexed separately. If the names or types of the subfields are not known in advance, then they are [mapped dynamically](docs-content://manage-data/data-store/mapping/dynamic-mapping.md).\n\nThe `flattened` type provides an alternative approach, where the entire object is mapped as a single field. Given an object, the `flattened` mapping will parse out its leaf values and index them into one field as keywords. The object\u2019s contents can then be searched through simple queries and aggregations.\n\nThis data type can be useful for indexing objects with a large or unknown number of unique keys. Only one field mapping is created for the whole JSON object, which can help prevent a [mappings explosion](docs-content://manage-data/data-store/mapping.md#mapping-limit-settings) from having too many distinct field mappings.\n\nOn the other hand, flattened object fields present a trade-off in terms of search functionality. Only basic queries are allowed, with no support for numeric range queries or highlighting. Further information on the limitations can be found in the [Supported operations](#supported-operations) section.\n\n::::{note}\nThe `flattened` mapping type should **not** be used for indexing all document content, as it treats all values as keywords and does not provide full search functionality. The default approach, where each subfield has its own entry in the mappings, works well in the majority of cases.\n::::\n\n\nA flattened object field can be created as follows:\n\n```console\nPUT bug_reports\n{\n  \"mappings\": {\n    \"properties\": {\n      \"title\": {\n        \"type\": \"text\"\n      },\n      \"labels\": {\n        \"type\": \"flattened\"\n      }\n    }\n  }\n}\n\nPOST bug_reports/_doc/1\n{\n  \"title\": \"Results are not sorted correctly.\",\n  \"labels\": {\n    \"priority\": \"urgent\",\n    \"release\": [\"v1.2.5\", \"v1.3.0\"],\n    \"timestamp\": {\n      \"created\": 1541458026,\n      \"closed\": 1541457010\n    }\n  }\n}\n```\n\nDuring indexing, tokens are created for each leaf value in the JSON object. The values are indexed as string keywords, without analysis or special handling for numbers or dates.\n\nQuerying the top-level `flattened` field searches all leaf values in the object:\n\n```console\nPOST bug_reports/_search\n{\n  \"query\": {\n    \"term\": {\"labels\": \"urgent\"}\n  }\n}\n```\n\nTo query on a specific key in the flattened object, object dot notation is used:\n\n```console\nPOST bug_reports/_search\n{\n  \"query\": {\n    \"term\": {\"labels.release\": \"v1.3.0\"}\n  }\n}\n```\n\n## Supported operations [supported-operations]\n\nBecause of the similarities in the way values are indexed, `flattened` fields share much of the same mapping and search functionality as [`keyword`](/reference/elasticsearch/mapping-reference/keyword.md) fields.\n\nCurrently, flattened object fields can be used with the following query types:\n\n* `term`, `terms`, and `terms_set`\n* `prefix`\n* `range`\n* `match` and `multi_match`\n* `query_string` and `simple_query_string`\n* `exists`\n\nWhen querying, it is not possible to refer to field keys using wildcards, as in `{ \"term\": {\"labels.time*\": 1541457010}}`. Note that all queries, including `range`, treat the values as string keywords. Highlighting is not supported on `flattened` fields.\n\nIt is possible to sort on a flattened object field, as well as perform simple keyword-style aggregations such as `terms`. As with queries, there is no special support for numerics \u2014 all values in the JSON object are treated as keywords. When sorting, this implies that values are compared lexicographically.\n\nFlattened object fields currently cannot be stored. It is not possible to specify the [`store`](/reference/elasticsearch/mapping-reference/mapping-store.md) parameter in the mapping.\n\n\n## Retrieving flattened fields [search-fields-flattened]\n\nField values and concrete subfields can be retrieved using the [fields parameter](/reference/elasticsearch/rest-apis/retrieve-selected-fields.md#search-fields-param). content. Since the `flattened` field maps an entire object with potentially many subfields as a single field, the response contains the unaltered structure from `_source`.\n\nSingle subfields, however, can be fetched by specifying them explicitly in the request. This only works for concrete paths, but not using wildcards:\n\n```console\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"flattened_field\": {\n        \"type\": \"flattened\"\n      }\n    }\n  }\n}\n\nPUT my-index-000001/_doc/1?refresh=true\n{\n  \"flattened_field\" : {\n    \"subfield\" : \"value\"\n  }\n}\n\nPOST my-index-000001/_search\n{\n  \"fields\": [\"flattened_field.subfield\"],\n  \"_source\": false\n}\n```\n\n```console-result\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 1,\n    \"successful\": 1,\n    \"skipped\": 0,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": {\n      \"value\": 1,\n      \"relation\": \"eq\"\n    },\n    \"max_score\": 1.0,\n    \"hits\": [{\n      \"_index\": \"my-index-000001\",\n      \"_id\": \"1\",\n      \"_score\": 1.0,\n      \"fields\": {\n        \"flattened_field.subfield\" : [ \"value\" ]\n      }\n    }]\n  }\n}\n```\n\nYou can also use a [Painless script](docs-content://explore-analyze/scripting/modules-scripting-painless.md) to retrieve values from sub-fields of flattened fields. Instead of including `doc['<field_name>'].value` in your Painless script, use `doc['<field_name>.<sub-field_name>'].value`. For example, if you have a flattened field called `label` with a `release` sub-field, your Painless script would be `doc['labels.release'].value`.\n\nFor example, let\u2019s say your mapping contains two fields, one of which is of the `flattened` type:\n\n```console\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"title\": {\n        \"type\": \"text\"\n      },\n      \"labels\": {\n        \"type\": \"flattened\"\n      }\n    }\n  }\n}\n```\n\nIndex a few documents containing your mapped fields. The `labels` field has three sub-fields:\n\n```console\nPOST /my-index-000001/_bulk?refresh\n{\"index\":{}}\n{\"title\":\"Something really urgent\",\"labels\":{\"priority\":\"urgent\",\"release\":[\"v1.2.5\",\"v1.3.0\"],\"timestamp\":{\"created\":1541458026,\"closed\":1541457010}}}\n{\"index\":{}}\n{\"title\":\"Somewhat less urgent\",\"labels\":{\"priority\":\"high\",\"release\":[\"v1.3.0\"],\"timestamp\":{\"created\":1541458026,\"closed\":1541457010}}}\n{\"index\":{}}\n{\"title\":\"Not urgent\",\"labels\":{\"priority\":\"low\",\"release\":[\"v1.2.0\"],\"timestamp\":{\"created\":1541458026,\"closed\":1541457010}}}\n```\n\nBecause `labels` is a `flattened` field type, the entire object is mapped as a single field. To retrieve values from this sub-field in a Painless script, use the `doc['<field_name>.<sub-field_name>'].value` format.\n\n```painless\n\"script\": {\n  \"source\": \"\"\"\n    if (doc['labels.release'].value.equals('v1.3.0'))\n    {emit(doc['labels.release'].value)}\n    else{emit('Version mismatch')}\n  \"\"\"\n```\n\n\n## Parameters for flattened object fields [flattened-params]\n\nThe following mapping parameters are accepted:\n\n`depth_limit`\n:   The maximum allowed depth of the flattened object field, in terms of nested inner objects. If a flattened object field exceeds this limit, then an error will be thrown. Defaults to `20`. Note that `depth_limit` can be updated dynamically through the [update mapping](https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-indices-put-mapping) API.\n\n[`doc_values`](/reference/elasticsearch/mapping-reference/doc-values.md)\n:   Should the field be stored on disk in a column-stride fashion, so that it can later be used for sorting, aggregations, or scripting? Accepts `true` (default) or `false`.\n\n[`eager_global_ordinals`](/reference/elasticsearch/mapping-reference/eager-global-ordinals.md)\n:   Should global ordinals be loaded eagerly on refresh? Accepts `true` or `false` (default). Enabling this is a good idea on fields that are frequently used for terms aggregations.\n\n[`ignore_above`](/reference/elasticsearch/mapping-reference/ignore-above.md)\n:   Leaf values longer than this limit will not be indexed. By default, there is no limit and all values will be indexed. Note that this limit applies to the leaf values within the flattened object field, and not the length of the entire field.\n\n[`index`](/reference/elasticsearch/mapping-reference/mapping-index.md)\n:   Determines if the field should be searchable. Accepts `true` (default) or `false`.\n\n[`index_options`](/reference/elasticsearch/mapping-reference/index-options.md)\n:   What information should be stored in the index for scoring purposes. Defaults to `docs` but can also be set to `freqs` to take term frequency into account when computing scores.\n\n[`null_value`](/reference/elasticsearch/mapping-reference/null-value.md)\n:   A string value which is substituted for any explicit `null` values within the flattened object field. Defaults to `null`, which means null fields are treated as if they were missing.\n\n[`similarity`](/reference/elasticsearch/mapping-reference/similarity.md)\n:   Which scoring algorithm or *similarity* should be used. Defaults to `BM25`.\n\n`split_queries_on_whitespace`\n:   Whether [full text queries](/reference/query-languages/query-dsl/full-text-queries.md) should split the input on whitespace when building a query for this field. Accepts `true` or `false` (default).\n\n`time_series_dimensions`\n:   (Optional, array of strings) A list of fields inside the flattened object, where each field is a dimension of the time series. Each field is specified using the relative path from the root field and does not include the root field name.\n\n\n## Synthetic `_source` [flattened-synthetic-source]\n\nFlattened fields support [synthetic`_source`](/reference/elasticsearch/mapping-reference/mapping-source-field.md#synthetic-source) in their default configuration.\n\nSynthetic source may sort `flattened` field values and remove duplicates. For example:\n\n$$$synthetic-source-flattened-sorting-example$$$\n\n```console\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"flattened\": { \"type\": \"flattened\" }\n    }\n  }\n}\nPUT idx/_doc/1\n{\n  \"flattened\": {\n    \"field\": [ \"apple\", \"apple\", \"banana\", \"avocado\", \"10\", \"200\", \"AVOCADO\", \"Banana\", \"Tangerine\" ]\n  }\n}\n```\n\nWill become:\n\n```console-result\n{\n  \"flattened\": {\n    \"field\": [ \"10\", \"200\", \"AVOCADO\", \"Banana\", \"Tangerine\", \"apple\", \"avocado\", \"banana\" ]\n  }\n}\n```\n\nSynthetic source always uses nested objects instead of array of objects. For example:\n\n$$$synthetic-source-flattened-array-example$$$\n\n```console\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"flattened\": { \"type\": \"flattened\" }\n    }\n  }\n}\nPUT idx/_doc/1\n{\n  \"flattened\": {\n      \"field\": [\n        { \"id\": 1, \"name\": \"foo\" },\n        { \"id\": 2, \"name\": \"bar\" },\n        { \"id\": 3, \"name\": \"baz\" }\n      ]\n  }\n}\n```\n\nWill become (note the nested objects instead of the \"flattened\" array):\n\n```console-result\n{\n    \"flattened\": {\n      \"field\": {\n          \"id\": [ \"1\", \"2\", \"3\" ],\n          \"name\": [ \"bar\", \"baz\", \"foo\" ]\n      }\n    }\n}\n```\n\nSynthetic source always uses single-valued fields for one-element arrays. For example:\n\n$$$synthetic-source-flattened-single-value-example$$$\n\n```console\nPUT idx\n{\n  \"settings\": {\n    \"index\": {\n      \"mapping\": {\n        \"source\": {\n          \"mode\": \"synthetic\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"flattened\": { \"type\": \"flattened\" }\n    }\n  }\n}\nPUT idx/_doc/1\n{\n  \"flattened\": {\n    \"field\": [ \"foo\" ]\n  }\n}\n```\n\nWill become (note the nested objects instead of the \"flattened\" array):\n\n```console-result\n{\n  \"flattened\": {\n    \"field\": \"foo\"\n  }\n}\n```\n\nFlattened fields allow for a key to contain both an object and a scalar value.\nFor example, consider the following flattened field `flattened`:\n\n```console-result\n{\n  \"flattened\": {\n    \"foo.bar\": \"10\",\n    \"foo\": {\n      \"bar\": {\n        \"baz\": \"20\"\n      }\n    }\n  }\n}\n```\n\nBecause `\"foo.bar\": \"10\"` is implicitly equivalent to `\"foo\": { \"bar\": \"10\" }`,\n`\"bar\"` has both a scalar value `\"10\"`, and an object value of `{ \"baz\": \"20\" }`.\n\nWith synthetic source, to produce a valid JSON output, objects with such fields will appear differently in `_source`.\nFor example, if the field is defined in an index configured with synthetic source, the value of `_source` would be:\n\n```console-result\n{\n  \"flattened\": {\n    \"foo\": {\n      \"bar\": \"10\",\n      \"bar.baz\": \"20\"\n    }\n  }\n}\n```",
              "filename": "elasticsearch-main/docs/reference/elasticsearch/mapping-reference/flattened.md"
            },
            {
              "mapped_pages": [
                "https://www.elastic.co/guide/en/elasticsearch/reference/current/properties.html"
              ],
              "content": "# properties [properties]\n\nType mappings, [`object` fields](/reference/elasticsearch/mapping-reference/object.md) and [`nested` fields](/reference/elasticsearch/mapping-reference/nested.md) contain sub-fields, called `properties`. These properties may be of any [data type](/reference/elasticsearch/mapping-reference/field-data-types.md), including `object` and `nested`. Properties can be added:\n\n* explicitly by defining them when [creating an index](https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-indices-create).\n* explicitly by defining them when adding or updating a mapping type with the [update mapping](https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-indices-put-mapping) API.\n* [dynamically](docs-content://manage-data/data-store/mapping/dynamic-mapping.md) just by indexing documents containing new fields.\n\nBelow is an example of adding `properties` to a mapping type, an `object` field, and a `nested` field:\n\n```console\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": { <1>\n      \"manager\": {\n        \"properties\": { <2>\n          \"age\":  { \"type\": \"integer\" },\n          \"name\": { \"type\": \"text\"  }\n        }\n      },\n      \"employees\": {\n        \"type\": \"nested\",\n        \"properties\": { <3>\n          \"age\":  { \"type\": \"integer\" },\n          \"name\": { \"type\": \"text\"  }\n        }\n      }\n    }\n  }\n}\n\nPUT my-index-000001/_doc/1 <4>\n{\n  \"region\": \"US\",\n  \"manager\": {\n    \"name\": \"Alice White\",\n    \"age\": 30\n  },\n  \"employees\": [\n    {\n      \"name\": \"John Smith\",\n      \"age\": 34\n    },\n    {\n      \"name\": \"Peter Brown\",\n      \"age\": 26\n    }\n  ]\n}\n```\n\n1. Properties in the top-level mappings definition.\n2. Properties under the `manager` object field.\n3. Properties under the `employees` nested field.\n4. An example document which corresponds to the above mapping.\n\n\n::::{tip}\nThe `properties` setting is allowed to have different settings for fields of the same name in the same index. New properties can be added to existing fields using the [update mapping API](https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-indices-put-mapping).\n::::\n\n\n## Dot notation [_dot_notation]\n\nInner fields can be referred to in queries, aggregations, etc., using *dot notation*:\n\n```console\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"match\": {\n      \"manager.name\": \"Alice White\"\n    }\n  },\n  \"aggs\": {\n    \"Employees\": {\n      \"nested\": {\n        \"path\": \"employees\"\n      },\n      \"aggs\": {\n        \"Employee Ages\": {\n          \"histogram\": {\n            \"field\": \"employees.age\",\n            \"interval\": 5\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n::::{important}\nThe full path to the inner field must be specified.\n::::",
              "filename": "elasticsearch-main/docs/reference/elasticsearch/mapping-reference/properties.md"
            },
            {
              "navigation_title": "Reverse nested",
              "mapped_pages": [
                "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-reverse-nested-aggregation.html"
              ],
              "content": "# Reverse nested aggregation [search-aggregations-bucket-reverse-nested-aggregation]\n\n\nA special single bucket aggregation that enables aggregating on parent docs from nested documents. Effectively this aggregation can break out of the nested block structure and link to other nested structures or the root document, which allows nesting other aggregations that aren\u2019t part of the nested object in a nested aggregation.\n\nThe `reverse_nested` aggregation must be defined inside a `nested` aggregation.\n\n* `path` - Which defines to what nested object field should be joined back. The default is empty, which means that it joins back to the root / main document level. The path cannot contain a reference to a nested object field that falls outside the `nested` aggregation\u2019s nested structure a `reverse_nested` is in.\n\nFor example, lets say we have an index for a ticket system with issues and comments. The comments are inlined into the issue documents as nested documents. The mapping could look like:\n\n$$$reversed-nested-aggregation-example$$$\n\n```console\nPUT /issues\n{\n  \"mappings\": {\n    \"properties\": {\n      \"tags\": { \"type\": \"keyword\" },\n      \"comments\": {                            <1>\n        \"type\": \"nested\",\n        \"properties\": {\n          \"username\": { \"type\": \"keyword\" },\n          \"comment\": { \"type\": \"text\" }\n        }\n      }\n    }\n  }\n}\n```\n\n1. The `comments` is an array that holds nested documents under the `issue` object.\n\n\nThe following aggregations will return the top commenters' username that have commented and per top commenter the top tags of the issues the user has commented on:\n\n```console\nGET /issues/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"aggs\": {\n    \"comments\": {\n      \"nested\": {\n        \"path\": \"comments\"\n      },\n      \"aggs\": {\n        \"top_usernames\": {\n          \"terms\": {\n            \"field\": \"comments.username\"\n          },\n          \"aggs\": {\n            \"comment_to_issue\": {\n              \"reverse_nested\": {}, <1>\n              \"aggs\": {\n                \"top_tags_per_comment\": {\n                  \"terms\": {\n                    \"field\": \"tags\"\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nAs you can see above, the `reverse_nested` aggregation is put in to a `nested` aggregation as this is the only place in the dsl where the `reverse_nested` aggregation can be used. Its sole purpose is to join back to a parent doc higher up in the nested structure.\n\n1. A `reverse_nested` aggregation that joins back to the root / main document level, because no `path` has been defined. Via the `path` option the `reverse_nested` aggregation can join back to a different level, if multiple layered nested object types have been defined in the mapping\n\n\nPossible response snippet:\n\n```console-result\n{\n  \"aggregations\": {\n    \"comments\": {\n      \"doc_count\": 1,\n      \"top_usernames\": {\n        \"doc_count_error_upper_bound\" : 0,\n        \"sum_other_doc_count\" : 0,\n        \"buckets\": [\n          {\n            \"key\": \"username_1\",\n            \"doc_count\": 1,\n            \"comment_to_issue\": {\n              \"doc_count\": 1,\n              \"top_tags_per_comment\": {\n                \"doc_count_error_upper_bound\" : 0,\n                \"sum_other_doc_count\" : 0,\n                \"buckets\": [\n                  {\n                    \"key\": \"tag_1\",\n                    \"doc_count\": 1\n                  }\n                  ...\n                ]\n              }\n            }\n          }\n          ...\n        ]\n      }\n    }\n  }\n}\n```",
              "filename": "elasticsearch-main/docs/reference/aggregations/search-aggregations-bucket-reverse-nested-aggregation.md"
            },
            {
              "navigation_title": "Nested",
              "mapped_pages": [
                "https://www.elastic.co/guide/en/elasticsearch/reference/current/nested.html"
              ],
              "content": "# Nested field type [nested]\n\n\nThe `nested` type is a specialised version of the [`object`](/reference/elasticsearch/mapping-reference/object.md) data type that allows arrays of objects to be indexed in a way that they can be queried independently of each other.\n\n::::{tip}\nWhen ingesting key-value pairs with a large, arbitrary set of keys, you might consider modeling each key-value pair as its own nested document with `key` and `value` fields. Instead, consider using the [flattened](/reference/elasticsearch/mapping-reference/flattened.md) data type, which maps an entire object as a single field and allows for simple searches over its contents. Nested documents and queries are typically expensive, so using the `flattened` data type for this use case is a better option.\n::::\n\n\n::::{warning}\nNested fields have incomplete support in Kibana. While they are visible and searchable in Discover, they cannot be used to build visualizations in Lens.\n::::\n\n\n## How arrays of objects are flattened [nested-arrays-flattening-objects]\n\nElasticsearch has no concept of inner objects. Therefore, it flattens object hierarchies into a simple list of field names and values. For instance, consider the following document:\n\n```console\nPUT my-index-000001/_doc/1\n{\n  \"group\" : \"fans\",\n  \"user\" : [ <1>\n    {\n      \"first\" : \"John\",\n      \"last\" :  \"Smith\"\n    },\n    {\n      \"first\" : \"Alice\",\n      \"last\" :  \"White\"\n    }\n  ]\n}\n```\n\n1. The `user` field is dynamically added as a field of type `object`.\n\n\nThe previous document would be transformed internally into a document that looks more like this:\n\n```js\n{\n  \"group\" :        \"fans\",\n  \"user.first\" : [ \"alice\", \"john\" ],\n  \"user.last\" :  [ \"smith\", \"white\" ]\n}\n```\n\nThe `user.first` and `user.last` fields are flattened into multi-value fields, and the association between `alice` and `white` is lost. This document would incorrectly match a query for `alice AND smith`:\n\n```console\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        { \"match\": { \"user.first\": \"Alice\" }},\n        { \"match\": { \"user.last\":  \"Smith\" }}\n      ]\n    }\n  }\n}\n```\n\n\n## Using `nested` fields for arrays of objects [nested-fields-array-objects]\n\nIf you need to index arrays of objects and to maintain the independence of each object in the array, use the `nested` data type instead of the [`object`](/reference/elasticsearch/mapping-reference/object.md) data type.\n\nInternally, nested objects index each object in the array as a separate hidden document, meaning that each nested object can be queried independently of the others with the [`nested` query](/reference/query-languages/query-dsl/query-dsl-nested-query.md):\n\n```console\nPUT my-index-000001\n{\n  \"mappings\": {\n    \"properties\": {\n      \"user\": {\n        \"type\": \"nested\" <1>\n      }\n    }\n  }\n}\n\nPUT my-index-000001/_doc/1\n{\n  \"group\" : \"fans\",\n  \"user\" : [\n    {\n      \"first\" : \"John\",\n      \"last\" :  \"Smith\"\n    },\n    {\n      \"first\" : \"Alice\",\n      \"last\" :  \"White\"\n    }\n  ]\n}\n\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"nested\": {\n      \"path\": \"user\",\n      \"query\": {\n        \"bool\": {\n          \"must\": [\n            { \"match\": { \"user.first\": \"Alice\" }},\n            { \"match\": { \"user.last\":  \"Smith\" }} <2>\n          ]\n        }\n      }\n    }\n  }\n}\n\nGET my-index-000001/_search\n{\n  \"query\": {\n    \"nested\": {\n      \"path\": \"user\",\n      \"query\": {\n        \"bool\": {\n          \"must\": [\n            { \"match\": { \"user.first\": \"Alice\" }},\n            { \"match\": { \"user.last\":  \"White\" }} <3>\n          ]\n        }\n      },\n      \"inner_hits\": { <4>\n        \"highlight\": {\n          \"fields\": {\n            \"user.first\": {}\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n1. The `user` field is mapped as type `nested` instead of type `object`.\n2. This query doesn\u2019t match because `Alice` and `Smith` are not in the same nested object.\n3. This query matches because `Alice` and `White` are in the same nested object.\n4. `inner_hits` allow us to highlight the matching nested documents.\n\n\n\n## Interacting with `nested` documents [nested-accessing-documents]\n\nNested documents can be:\n\n* queried with the [`nested`](/reference/query-languages/query-dsl/query-dsl-nested-query.md) query.\n* analyzed with the [`nested`](/reference/aggregations/search-aggregations-bucket-nested-aggregation.md) and [`reverse_nested`](/reference/aggregations/search-aggregations-bucket-reverse-nested-aggregation.md) aggregations.\n* sorted with [nested sorting](/reference/elasticsearch/rest-apis/sort-search-results.md#nested-sorting).\n* retrieved and highlighted with [nested inner hits](/reference/elasticsearch/rest-apis/retrieve-inner-hits.md#nested-inner-hits).\n\n::::{important}\nBecause nested documents are indexed as separate documents, they can only be accessed within the scope of the `nested` query, the `nested`/`reverse_nested` aggregations, or [nested inner hits](/reference/elasticsearch/rest-apis/retrieve-inner-hits.md#nested-inner-hits).\n\nFor instance, if a string field within a nested document has [`index_options`](/reference/elasticsearch/mapping-reference/index-options.md) set to `offsets` to allow use of the postings during the highlighting, these offsets will not be available during the main highlighting phase. Instead, highlighting needs to be performed via [nested inner hits](/reference/elasticsearch/rest-apis/retrieve-inner-hits.md#nested-inner-hits). The same consideration applies when loading fields during a search through [`docvalue_fields`](/reference/elasticsearch/rest-apis/retrieve-selected-fields.md#docvalue-fields) or [`stored_fields`](/reference/elasticsearch/rest-apis/retrieve-selected-fields.md#stored-fields).\n\n::::\n\n\n\n## Parameters for `nested` fields [nested-params]\n\nThe following parameters are accepted by `nested` fields:\n\n[`dynamic`](/reference/elasticsearch/mapping-reference/dynamic.md)\n:   (Optional, string) Whether or not new `properties` should be added dynamically to an existing nested object. Accepts `true` (default), `false` and `strict`.\n\n[`properties`](/reference/elasticsearch/mapping-reference/properties.md)\n:   (Optional, object) The fields within the nested object, which can be of any [data type](/reference/elasticsearch/mapping-reference/field-data-types.md), including `nested`. New properties may be added to an existing nested object.\n\n`include_in_parent`\n:   (Optional, Boolean) If `true`, all fields in the nested object are also added to the parent document as standard (flat) fields. Defaults to `false`.\n\n`include_in_root`\n:   (Optional, Boolean) If `true`, all fields in the nested object are also added to the root document as standard (flat) fields. Defaults to `false`.\n\n\n## Limits on `nested` mappings and objects [_limits_on_nested_mappings_and_objects]\n\nAs described earlier, each nested object is indexed as a separate Lucene document. Continuing with the previous example, if we indexed a single document containing 100 `user` objects, then 101 Lucene documents would be created: one for the parent document, and one for each nested object. Because of the expense associated with `nested` mappings, Elasticsearch puts settings in place to guard against performance problems:\n\n`index.mapping.nested_fields.limit`\n:   The maximum number of distinct `nested` mappings in an index. The `nested` type should only be used in special cases, when arrays of objects need to be queried independently of each other. To safeguard against poorly designed mappings, this setting limits the number of unique `nested` types per index. Default is `50`.\n\nIn the previous example, the `user` mapping would count as only 1 towards this limit.\n\n`index.mapping.nested_objects.limit`\n:   The maximum number of nested JSON objects that a single document can contain across all `nested` types. This limit helps to prevent out of memory errors when a document contains too many nested objects. Default is `10000`.\n\nTo illustrate how this setting works, consider adding another `nested` type called `comments` to the previous example mapping. For each document, the combined number of `user` and `comment` objects it contains must be below the limit.\n\nSee [Prevent mapping explosions](docs-content://manage-data/data-store/mapping.md#mapping-limit-settings) regarding additional settings for preventing mappings explosion.",
              "filename": "elasticsearch-main/docs/reference/elasticsearch/mapping-reference/nested.md"
            }
          ],
          "tool_call_id": "call_DJ6Y321I7B9DhMTZV5vUufsj",
          "metadata": null,
          "timestamp": "2025-10-03T06:01:11.894759+00:00",
          "part_kind": "tool-return"
        }
      ],
      "instructions": "You are a helpful assistant that answers questions about documentation.  \n\nUse the search tool to find relevant information from the repository before answering questions.  \n\nIf you can find specific information through search, use it to provide accurate answers.\n\nAlways include references by citing the filename of the source material you used.\nReplace it with the full path to the GitHub repository:\n\"https://github.com/elastic/elasticsearch/blob/main/\"\nFormat: [LINK TITLE](FULL_GITHUB_LINK)\n\n\nIf the search doesn't return relevant results, let the user know and provide general guidance.",
      "kind": "request"
    },
    {
      "parts": [
        {
          "content": "Flattening nested objects in the `attributes` and `resource.attributes` maps in Elasticsearch is significant for several reasons related to efficiency and search capabilities:\n\n1. **Ease of Querying**: Flattening allows the entire object to be mapped into a single field, making it easier to query. When using the `flattened` field type, all leaf values of the JSON object are indexed together, allowing simple queries and aggregations to be executed more efficiently.\n\n2. **Preventing Mappings Explosion**: When objects have a large or arbitrary number of unique keys, mapping them dynamically can lead to a \"mapping explosion\" where too many distinct field mappings are created. Flattened mapping creates a single field mapping for the entire JSON object, therefore controlling the mapping size and complexity significantly.\n\n3. **Simplified Data Model**: Flattening can simplify the data model when dealing with complex or unknown field structures. Rather than needing to define multiple subfields under an object or nested type, flattening allows treating the entire structure as a single entity, which can reduce maintenance overhead.\n\n4. **Limitations of Nested Fields**: Using nested fields can be resource-intensive (each nested object is indexed as a separate hidden document), making performance management more challenging. In contrast, flattened fields present slightly restricted capabilities but improve performance and reduce complexity by allowing basic search functionality without the expensive overhead of nested queries or aggregations.\n\n5. **Flexibility in Data Handling**: Flattened fields can simplify queries, allowing advanced filtering and searching capabilities without the costs associated with deeply nested structures. It allows operations such as sorting and aggregations based on the flat field mappings.\n\nHowever, it's important to note that the `flattened` mapping should not be employed when comprehensive search functionalities (like numeric range queries or complex querying on subfields) are needed, as these operations are limited on flattened fields compared to traditional nested structures.\n\nFor additional details, see the complete references:\n- [Flattened field type](https://github.com/elastic/elasticsearch/blob/main/docs/reference/elasticsearch/mapping-reference/flattened.md)\n- [Nested field type](https://github.com/elastic/elasticsearch/blob/main/docs/reference/elasticsearch/mapping-reference/nested.md)",
          "id": null,
          "part_kind": "text"
        }
      ],
      "usage": {
        "input_tokens": 8833,
        "cache_write_tokens": 0,
        "cache_read_tokens": 0,
        "output_tokens": 444,
        "input_audio_tokens": 0,
        "cache_audio_read_tokens": 0,
        "output_audio_tokens": 0,
        "details": {
          "accepted_prediction_tokens": 0,
          "audio_tokens": 0,
          "reasoning_tokens": 0,
          "rejected_prediction_tokens": 0
        }
      },
      "model_name": "gpt-4o-mini-2024-07-18",
      "timestamp": "2025-10-03T06:01:12+00:00",
      "kind": "response",
      "provider_name": "openai",
      "provider_details": {
        "finish_reason": "stop"
      },
      "provider_response_id": "chatcmpl-CMT8qhSb137AqMCdHGFh60c4i722x",
      "finish_reason": "stop"
    }
  ],
  "source": "ai-generated"
}